import express from 'express';
import pkg from 'pg';
const { Pool } = pkg;

const router = express.Router();

// Database connection pool
const pool = new Pool({
  host: process.env.DB_HOST || 'localhost',
  port: process.env.DB_PORT || 5432,
  database: process.env.DB_NAME || 'ecom_dash',
  user: process.env.DB_USER || 'postgres',
  password: process.env.DB_PASSWORD || 'Makhas037@123*',
  max: 20,
});

pool.on('connect', () => {
  console.log('✅ Routes connected to database');
});

// Health check
router.get('/health', (req, res) => {
  res.json({ 
    status: 'ok', 
    timestamp: new Date().toISOString()
  });
});

// Get all sales with pagination
router.get('/sales', async (req, res) => {
  try {
    const page = parseInt(req.query.page) || 1;
    const limit = parseInt(req.query.limit) || 50;
    const offset = (page - 1) * limit;
    
    const salesQuery = 'SELECT * FROM sales ORDER BY created_at DESC LIMIT $1 OFFSET $2';
    const countQuery = 'SELECT COUNT(*) FROM sales';
    
    const [salesResult, countResult] = await Promise.all([
      pool.query(salesQuery, [limit, offset]),
      pool.query(countQuery)
    ]);
    
    res.json({
      data: salesResult.rows,
      pagination: {
        page,
        limit,
        total: parseInt(countResult.rows[0].count),
        pages: Math.ceil(countResult.rows[0].count / limit)
      }
    });
  } catch (error) {
    console.error('Sales error:', error);
    res.status(500).json({ error: error.message });
  }
});

// Analytics dashboard
router.get('/analytics/dashboard', async (req, res) => {
  try {
    const kpisQuery = `
      SELECT 
        COUNT(*) as total_sales,
        COALESCE(SUM(amount), 0) as total_revenue,
        COALESCE(AVG(amount), 0) as avg_order_value,
        COUNT(DISTINCT customer_id) as unique_customers
      FROM sales
      WHERE sale_date >= CURRENT_DATE - INTERVAL '30 days'
    `;
    
    const recentSalesQuery = 'SELECT * FROM sales ORDER BY created_at DESC LIMIT 10';
    
    const [kpis, recentSales] = await Promise.all([
      pool.query(kpisQuery),
      pool.query(recentSalesQuery)
    ]);
    
    res.json({
      kpis: kpis.rows[0],
      recentSales: recentSales.rows,
      topProducts: [],
      customerStats: {}
    });
  } catch (error) {
    console.error('Analytics error:', error);
    res.status(500).json({ error: error.message });
  }
});

// Gemini AI Chat endpoint - UPDATED WITH WORKING MODEL
router.post('/gemini/chat', async (req, res) => {
  try {
    const { message, context } = req.body;
    
    if (!message) {
      return res.status(400).json({ error: 'Message is required' });
    }

    // Import GoogleGenerativeAI
    const { GoogleGenerativeAI } = await import('@google/generative-ai');
    
    const apiKey = process.env.GEMINI_API_KEY || 'AIzaSyCs0rVYHFMKL3lifcistmSUY90jKv059WY';
    const genAI = new GoogleGenerativeAI(apiKey);
    
    // Use gemini-2.5-flash (working model as of October 2025)
    const model = genAI.getGenerativeModel({ 
      model: 'gemini-2.5-flash'
    });

    // Build context-aware prompt
    let prompt = `You are Fick AI, an intelligent business analytics assistant for an e-commerce dashboard.\n\n`;
    
    if (context && context.salesData) {
      prompt += `Current business metrics:\n`;
      prompt += `- Total Sales: ${context.salesData.total_sales || 'N/A'}\n`;
      prompt += `- Total Revenue: $${context.salesData.total_revenue || 'N/A'}\n`;
      prompt += `- Average Order Value: $${context.salesData.avg_order_value || 'N/A'}\n`;
      prompt += `- Unique Customers: ${context.salesData.unique_customers || 'N/A'}\n\n`;
    }
    
    prompt += `User question: ${message}\n\n`;
    prompt += `Provide a helpful, concise, data-driven response. Keep it under 150 words.`;

    const result = await model.generateContent(prompt);
    const response = await result.response;
    const text = response.text();

    res.json({
      response: text,
      timestamp: new Date().toISOString(),
      model: 'gemini-2.5-flash'
    });
  } catch (error) {
    console.error('Gemini AI error:', error);
    
    // Fallback response if AI fails
    res.json({ 
      response: "I'm currently unable to process your request. The AI service may be temporarily unavailable. Please try asking: 'What are my sales?' or 'Show analytics'.",
      error: error.message,
      timestamp: new Date().toISOString(),
      fallback: true
    });
  }
});

// Get users
router.get('/users', async (req, res) => {
  try {
    const result = await pool.query('SELECT id, email, full_name, role FROM users');
    res.json({ data: result.rows });
  } catch (error) {
    console.error('Users error:', error);
    res.status(500).json({ error: error.message });
  }
});

// Get products
router.get('/products', async (req, res) => {
  try {
    const result = await pool.query('SELECT * FROM products');
    res.json({ data: result.rows });
  } catch (error) {
    console.error('Products error:', error);
    res.status(500).json({ error: error.message });
  }
});

// Get customers
router.get('/customers', async (req, res) => {
  try {
    const result = await pool.query('SELECT * FROM customers ORDER BY created_at DESC');
    res.json({ data: result.rows });
  } catch (error) {
    console.error('Customers error:', error);
    res.status(500).json({ error: error.message });
  }
});

export default router;
